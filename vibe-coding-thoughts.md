## Vibe-coding an R package: thoughts along the journey

This is my first vibe-coding project. I tried to not look into any function details even if I know how to fix, but force myself to do prompt-based coding only. It is a very interesting and educational experience...

I used Claude Sonnet 4 as my AI assistant. It is certainly also a vibe-based choice. I am sure experience with other LLMs will be different but somehow similar in broad strokes.

To start, Claude was very quick and effective in building a shiny dashboard to visualize things that I want to see in the package: what functions are their, dependencies, missing documents, etc. That takes only a couple minutes, everything seems great...

Then I start to demand more (i.e., what many of us would do when identifying a great students...) and ask for more complicated tasks. But unlike talking to a student, I can shameless ask for tedious tasks that I don't want waste my time on! There are many hacky things in building R packages that one typically do as they add functions and methods (e.g., checking the dependencies are correctly imported, fake global variable complaints from R Check are dealt with, documentations, etc.) I happily described them to Claude. Claude understands the issues immediately. This is great! When talking to a real person, unless the person is an R package experts, explaining what's going on and what needs to be done can take a very long time. 

Then Claude starts to add functions to implement the hacks (more on the readme file, after I get them to work). The danger of vibe coding starts to surface: the functions are written professionally with edge case handling and fail safes and useful messages, but they are very long! It soon becomes impossible to read the whole functions. And what's worse is that as the tasks become more complicated, the functions do not always work out of the gate. Now I am doing real vibe coding. I'm seeing the results, describing what's wrong, and brainlessly copy pasting the updated functions without thinking. I got some functionalities implemented fine in this way. It's not fast any more. An hour easily slipped away implementing a single functionality resolving some global variable check errors. For sure, I can manually edit the package to fix those issues in ten minutes, but the idea is to create something that can be reused later. Still, it's a lot faster than me trying to figure out the right regex to parse the R check notes...

But more problems arise. Claude initially set up an R6 object, which is super nice and modern, but as tasks accumulate, the main R6 code script needs to be updated constantly. Sometimes new mistakes are generated, and regenerating that file becomes time-consuming. Again, common problem when coding, functions become too big to deal with effectively. 

I finally decided to do a clean slate restart. I know there are many functionalities that have been tested already, but if I continue with this current codebase, there is no way I will come back doing anything else on it since it's totally unreadable...so it goes the prompt that I would rarely ask of a student lightly: _looking back at the whole project, the R6 implementation is really tedious and difficult to maintain in the future. Can you do a restructuring assessment to only use task-specific functions to achieve the same functionalities?_

A few minutes later, I have a full set of functions that does roughly the same thing based on names, but with completely different organizations! Great...but more debugging as things are not perfect. Many more conversations, and I have to come up with the right logic to check, rather than let Claude completely freestyle. For example, one of the task was to create roxygen template for any undocumented functions. Claude correctly implemented the idea, except that it creates the roxygen comments for internal functions too, which I do not want (or at least, would like to be able to toggle off). So I asked Claude to toggle off nested functions. It tried to implement it through three separate checks based on guesswork (line number, naming convention, etc.). I had to tell Claude to check for @export tag and only add template for exported functions -- something very intuitive for experienced R users, but I guess it's a very language-specific thing that does not come up as the first approach to take for Claude. Anyway, the experience is not too bad: you basically still need to know what you want to do and need to be able to describe it! That's not a bad skill to have... 


Still not fully done, but getting there...